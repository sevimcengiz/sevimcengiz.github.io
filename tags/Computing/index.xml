<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computing on Sevim Cengiz</title><link>https://sevimcengiz.github.io/tags/Computing/</link><description>Recent content in Computing on Sevim Cengiz</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 10 Jan 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://sevimcengiz.github.io/tags/Computing/index.xml" rel="self" type="application/rss+xml"/><item><title>What does it take to be a computational biologist?</title><link>https://sevimcengiz.github.io/blog/2014/01/10/what-does-it-take-to-be-a-computational-biologist/</link><pubDate>Fri, 10 Jan 2014 00:00:00 +0000</pubDate><guid>https://sevimcengiz.github.io/blog/2014/01/10/what-does-it-take-to-be-a-computational-biologist/</guid><description>
&lt;script src="https://sevimcengiz.github.io/rmarkdown-libs/header-attrs/header-attrs.js">&lt;/script>
&lt;p>I would like to talk about what it takes to be a computational biologist, specifically in comparison to being an experimental biologist. If you’re wondering whether instead of becoming a computational biologist you should become a race-car driver, fighter pilot, or ballet dancer, this post probably won’t help you. But if you’re wondering whether a computational biology lab is a better choice for you than an experimental biology lab, this post should provide you with some useful guidelines. To cut right to the chase, here is the take-home message: To become a computational biologist, you need to &lt;em>want&lt;/em> to become a computational biologist.&lt;/p>
&lt;p>When I interview students who are potentially interested in joining my lab, the interviews inevitably take one of two routes, depending on the students’ background. The students with extensive computational experience usually make a point emphasizing all the techniques, systems, and languages they have learned, to showcase their technical expertise. By contrast, the students with little computational experience are usually rather timid. They say that they might be interested in computational biology but don’t really know much about it, and also that they don’t know if they would be any good at it.&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a>&lt;/p>
&lt;p>The truth is, I don’t really worry much about pre-existing expertise.&lt;a href="#fn2" class="footnote-ref" id="fnref2">&lt;sup>2&lt;/sup>&lt;/a> Sure, I won’t be disappointed if a student knows a lot already, but it plays a rather minimal role in my decision of whether or not to take a particular student.&lt;a href="#fn3" class="footnote-ref" id="fnref3">&lt;sup>3&lt;/sup>&lt;/a> I think that computation can be learned relatively easily, &lt;em>if you really want to learn it,&lt;/em> so what matters much more than your current knowledge is your intention.&lt;a href="#fn4" class="footnote-ref" id="fnref4">&lt;sup>4&lt;/sup>&lt;/a> For this reason, when students express any concern about their ability to be computational biologists, I usually ask them a simple question: Would you rather spend your day in front of a bench pipetting, or would you rather spend your day in front of a computer screen staring at symbols and numbers? Anybody who would rather stare at a computer screen is going to be fine in my lab, and anybody who would rather pipette is not going to have a good time.&lt;/p>
&lt;p>In fact, too much pre-existing computational knowledge can be a disadvantage, when the students think they know things better than they actually do. At least the inexperienced students are a blank slate. They are willing to listen and they accept the conventions of the lab. The more experienced students may have idiosyncratic views on how things should be done, views that may make sense from their perspective but not from the perspective of the person running the lab (i.e., me). For example, a student who insists on using java for a project when the rest of the lab uses python is going to cause problems,&lt;a href="#fn5" class="footnote-ref" id="fnref5">&lt;sup>5&lt;/sup>&lt;/a> even if he has lots of experience with java and none with python. With some experienced students, I spend as much time re-training them as I would have spent with less experienced students training them from scratch.&lt;/p>
&lt;p>So, if you don’t have a lot of computational experience but you would like to do computational work, ask yourself whether you have the patience to hack away for hours in front of a computer screen, until you have solved a problem. If the answer is yes, you’ll be fine. And if you do already have a lot of computational experience, keep an open mind, realize that there is probably still a lot you can learn, and accept that some things are just conventions. Even if you don’t like a particular convention (such as “we use python”) you should accept it if you want to be successful in your lab.&lt;a href="#fn6" class="footnote-ref" id="fnref6">&lt;sup>6&lt;/sup>&lt;/a>&lt;/p>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>Actually, more recently there is also a third type, students who think they have computational experience but they really don’t. MS Word, Excel, or Facebook do not count as computational experience. If you have never written an actual program and never used a command line, you don’t have any meaningful experience.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2">&lt;p>This statement applies to undergraduate researchers or prospective graduate students. I wouldn’t hire a postdoc without any computational expertise. If somebody has done a purely experimental PhD they are unlikely going to be a good match for my lab at the postdoc stage, since we don’t do any experiments whatsoever.&lt;a href="#fnref2" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3">&lt;p>I tend to evaluate students primarily on whether they appear to be motivated, whether they appear to be smart, whether I can connect with them, and whether I think they would fit into the lab.&lt;a href="#fnref3" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn4">&lt;p>This point is also made &lt;a href="http://pgbovine.net/tech-privilege.htm">here.&lt;/a> As long as people give you a chance to try yourself at programming and you make an effort, you should be fine.&lt;a href="#fnref4" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn5">&lt;p>As just one example, it will be more difficult for other students to take advantage of that student’s work and vice versa. Further, once the student leaves, the project may be abandoned or somebody else may have to re-engineer it using the lab’s preferred language.&lt;a href="#fnref5" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn6">&lt;p>I acknowledge that there may be situations where the convention a lab has chosen is genuinely poor, and where the student truly knows better than the faculty member how to do things properly. However, I think these situations are rare, in particular for labs run by experienced computational biologists. And moreover, if you as a student really have so much computing experience that you can see all the poor decisions your PI is making, why did you join the lab in the first place? You should have seen these issues ahead of time. For example, if I were a prospective graduate student now, and I was told a lab did everything in perl and fortran, I’d run. By contrast, if they used languages I approve of, if they deposited their code on github, and if the code they deposited looked more or less decent, then I should be fine in that lab.&lt;a href="#fnref6" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Ten simple rules for reproducible computational research</title><link>https://sevimcengiz.github.io/blog/2013/10/26/ten-simple-rules-for-reproducible-computational-research/</link><pubDate>Sat, 26 Oct 2013 00:00:00 +0000</pubDate><guid>https://sevimcengiz.github.io/blog/2013/10/26/ten-simple-rules-for-reproducible-computational-research/</guid><description>
&lt;script src="https://sevimcengiz.github.io/rmarkdown-libs/header-attrs/header-attrs.js">&lt;/script>
&lt;p>PLOS Computational Biology just published a new addition to their popular &lt;a href="https://collections.plos.org/ten-simple-rules">“ten simple rules”&lt;/a> series:&lt;/p>
&lt;blockquote>
&lt;p>Sandve GK, Nekrutenko A, Taylor J, Hovig E (2013) Ten Simple Rules for Reproducible Computational Research. PLoS Comput Biol 9(10): e1003285. &lt;a href="https://doi.org/10.1371/journal.pcbi.1003285">doi:10.1371/journal.pcbi.1003285&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>This article is relevant to anybody who wants to do computational research. I’ll make it required reading in my lab. For every single one of these rules, I can think of projects I’ve been involved with&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a> that ran into trouble or failed because they violated that rule.&lt;/p>
&lt;p>While all of the rules are important, I’m particularly partial to these four: avoid manual data manipulation, record all intermediate results, always store raw data behind plots, and provide public access to scripts and results. They will prevent a lot of headaches for both you and the people coming after you who’d like to build on your results.&lt;/p>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>All of these projects were run by friends of friends, of course. None of this would ever happen in my lab. 😉&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Is consumer software creating a new generation of computer illiterates?</title><link>https://sevimcengiz.github.io/blog/2013/08/30/is-consumer-software-creating-a-new-generation-of-computer-illiterates/</link><pubDate>Fri, 30 Aug 2013 00:00:00 +0000</pubDate><guid>https://sevimcengiz.github.io/blog/2013/08/30/is-consumer-software-creating-a-new-generation-of-computer-illiterates/</guid><description>
&lt;script src="https://sevimcengiz.github.io/rmarkdown-libs/header-attrs/header-attrs.js">&lt;/script>
&lt;p>When I was growing up, computers were a still a pretty unusual thing. As a result, people could generally be subdivided into two types: those that knew their way around computers and those that didn’t. The ones that knew their way around computers really knew things, often down to the hardware level. (I had a book listing the entire operating system of my Commodore, in machine language.) The others pretty much knew nothing, &lt;em>and they knew that they knew nothing.&lt;/em> So the world was in order. Everybody knew their place. These days, computers are ubiquitous. Everybody and their dog knows how to fill out a web form or install an app. Yet unless we venture beyond the shiny interfaces provided by the Microsofts, Apples, and Googles of this world we remain just as illiterate as the earlier generation. We just don’t know how much we don’t know.&lt;/p>
&lt;p>What prompted me to write this post? At my university, I have the pleasure of using email service provided through Microsoft’s new Office365. And yesterday, I made the mistake of trying their email filtering solution. My goal was a simple one: Set up an email filter that takes all replies (but not original posts!) to a certain mailing list and moves those messages into a special folder. You should know that all messages to the list are tagged with a unique identifier, something like “[list-X]”, so it’s easy enough to find those messages. But how do we know a message is a reply, not an original post? Well, for original posts, “[list-X]” appears at the beginning of the subject line. For replies, the subject line usually begins with “Re: [list-X]” or “RE: [list-X]” or maybe even “Aw: [list-X]” (the latter happens if somebody is using an email program in the German language). So original posts and replies are easy enough to tell apart. All we have to do is create a filter rule that captures all posts whose subject contains, &lt;em>but doesn’t begin with,&lt;/em> the tag “[list-X]”. How hard could that be?&lt;/p>
&lt;p>Well, in Office365, this is a problem of infinite difficulty. It cannot be done. You can filter by sender, you can filter by receiver, you can filter by keywords in the subject line, but you cannot filter for specific sequences of words, and you cannot filter for words that do appear in the subject line but not at the beginning. Now, if you’re a modern-day computer illiterate, you may think: “Well, of course Microsoft programmers couldn’t include a separate option for any random combination of conditions somebody could come up with. They have to make reasonable selection among common cases, and there’s just no way around that.” If this is your thinking, then what you do not know is that computer scientists have long had a simple solution to this problem, a solution called “regular expression.” (If you’ve never heard of &lt;a href="http://en.wikipedia.org/wiki/Regular_expression">regular expressions&lt;/a>, look them up. They are super powerful. They are the computing equivalent of a swiss army knife, a chain saw, and a pickup truck all in one.) All Microsoft would have to do is add one more option, “filter by regular expression,” and I could create the most spectacular filtering rules. And this option is trivial to implement. It would take a skilled programmer about an afternoon to add. Likely, the underlying filtering software in Office365 already employs regular expressions, so all that Microsoft programmers would have to do is allow me to access that software layer directly. But they don’t, and so I can’t.&lt;/p>
&lt;p>Now, why don’t they add an option that would be tremendously useful and trivial to add? There are two possible interpretation. It’s either because they don’t want to scare us (benign interpretation) or because they don’t want us to be in control of our computers (malicious interpretation). Whatever the reason, the outcome is the same. If all you know is the polished user interface of consumer software, you’ll know computers as magical contraptions that can do incredible things, as long as somebody has thought of the things you might want to do. If you want to do something different, though, something unconventional, then that’s usually not possible, as far as you know. I suspect that if you have grown up in this environment, you don’t even know what it is you can’t do. You have no good mental model of the underlying technology, so you don’t know what should be easy and what might be difficult. Dumbed-down consumer software keeps you ignorant of the true power of computing technology.&lt;/p>
&lt;p>A conspiracy theorist might pose that this is done on purpose. If you don’t really understand how computers work and what they are capable of, you don’t realize how easy it would be to, for example, take the metadata&lt;a href="#fn1" class="footnote-ref" id="fnref1">&lt;sup>1&lt;/sup>&lt;/a> of your phone and text messages and figure out with whom you’re likely having an affair. I don’t really believe in massive conspiracies, though, so I think the more likely explanation is that in the effort of making software simple and accessible to all, it’s often easier and less work to simply hide the true underlying capabilities. Either way, the end result is the same. Plenty of people who think they know how to use computers but really they don’t.&lt;/p>
&lt;p>As to Office365, I’ll file a bug report. Fat chance they’ll act on it.&lt;/p>
&lt;div class="footnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1">&lt;p>Metadata in this case means call and text records, but without their content. Basically a list of who did you call when, who called you, who did you text, and who texted you.&lt;a href="#fnref1" class="footnote-back">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>